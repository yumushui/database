# Start-up period Storage


在一个电商系统的初创期，对于存储需要面对和解决的问题有：

```
创建和更新订单  —— 如何保证数据准确无误

商品详情页  ——  流量大、数据多，如何设计

购物车系统  —— 复杂而又重要，如何设计

账户余额系统 —— 余额总是对不上帐怎么办，事务

多个系统的的数据一致性 —— 如何保证，分布式事务

商品搜索系统 —— 如何构建，使用 Elaticsearch 

存储系统高可用 —— 如何将“删库跑路”的风险降到最低，备份与 MySQL MHA

```


## 一、订单系统

订单系统是整个电商系统中最重要的一个子系统，订单数据也是电商企业最重要的数据资产。在订单系统中的存储设计中，需要考虑的问题有那些？

一个合格的订单系统，最基本的要求是： **数据不能错**。

一个购物流程，有很多过程，需要更新很多表，在很多服务器和网络上可能出问题，所以订单系统的情况比较复杂。但要保证订单数据一笔都不能错，掌握了方法，并不难。

+ 首先，要保证代码没有bug；
+ 然后，要回正确的使用事务。通过事务，多个订单操作，要么全部成功，要么全部失败。

这些基本操作并不难，但每个订单系统在不同业务场景中，还可能有一些数据错误。但在讨论问题是，需要化繁为简，只考虑那些最核心的、通用的业务和功能，并以此来讨论存储技术问题。

### 1.1 订单系统的核心功能和数据

一个订单系统必备的功能，包含但远远不限于：

+ 1. 创建订单
+ 2. 随着购物流程更新订单状态
+ 3. 查询订单，包括用订单数据生成各种报表。

为了支撑这些必备功能，在数据库中，至少需要这样几个表：

+ 1. 订单主表：要叫订单表，保存订单的基本信息。
+ 2. 订单商品表：保存订单中的商品信息。
+ 3. 订单支付表：保存订单的支付和退款信息。
+ 4. 订单优惠表：保存订单的所有优惠信息。

这几个表之间的关系是： 订单主表和后面的几个子表都是一对多的关系，关联的外键就是订单主表的主键，也就是订单号。

绝大部分订单系统的核心功能和数据结构都是这样的。

### 1.2 如何避免重复下单

在“提交订单”是，如果手抖了一下，点了两下，或者网络问题，发了两个HTTP请求。这样就会创建两个完全一样的订单，所以订单要做防重。

前端页面可以做防重，但网络错误会导致重传，很多 RPC 框架、网络都会有自动重试机制，所以对于订单系统，重复请求的事情，是没有办法避免的。

解决办法是，**让你的订单具备幂等性**。幂等性，就是在操作中，任意多次执行所产生的影响与一次执行的影响相同。也就是说，一个幂等的方法，使用同样的参数，调用多次和调用一次，对系统产生的影响一样。
如果创建订单具有幂等性，就可以在数据库中只有一条新的创建的订单记录。

但还有一个问题是： 对于订单服务，它是如何知道一个请求是不是重复请求？

解决这个问题的最佳思路是： 数据库的每个表都要有主键，绝大部分数据表都遵循这个最佳实践。一般来说，我们在往数据库插入一条记录的时候，都不提供主键，由数据库在插入的同时，自动生成一个主键。这样就会重复的请求，就会导致插入重复数据。

我们知道，表的主键自带唯一属性，如果在一条 INSERT 语句中提供了主键，并且这个主键的值在表中已经存在，那么这条 INSERT 会执行失败，数据也不会写入表中。
**我们可以利用数据的这种“主键唯一约束”的特性，在插入数据时候带上主键，来解决订单服务的幂等性问题。**

具体的做法是，给订单系统增加一个“生成订单号”的服务，这个服务没有参数，返回值就是一个新的、全局唯一的订单号。在用户进入创建订单的页面时，前端先调用服务生成一个订单号，在提交订单时，请求带着这个订单号。

这个订单号，也就是订单表的主键，这样各种情况导致的重试，重复请求中都带着同一个订单号。订单服务在订单表中插入数据的时候，执行这些重复的 INSERT 语句的主键，也都是同一个订单号。数据库的唯一约束就可以保证，只有一次insert语句是执行成功的，这样就实现了创建订单服务幂等性。


### 1.3 如何解决ABA问题

上面解决重复下单，是创建订单时要具有幂等性。同样，订单系统的各种更新服务一样也要具有幂等性。

订单更新服务，比如支付、发货等步骤的更新操作，最后落到数据库订单库上，都是对订单主表的 update 操作。数据库的更新操作，本身就具有天然的幂等性，如把订单状态从“未支付”更新成“已支付”，执行一次和重复多次，都是已支付，天然具有幂等性。

但在订单更新时，还需要注意其他问题。在并发环境中，需要注意**ABA问题**。
比如一个订单，需要修改为 666，发起请求后，数据库更新为 666，这个数据库返回的响应丢失了；但觉得 666错误了，又发起一个更新 888的操作，这时数据库记录变为888；但前面修改666的操作，由于响应丢失，发起重试，又修改为 666了。
这时第二次和第三次的成功影响返回前端，但实际数据库中但记录为 666，并不是我们期望的 888.存在数据错误。

ABA 问题的解决，有一个通用的思路： 给订单主表增加一列，列名可以叫 version，也就是”版本号的意思。每次查询订单的时候，版本号要随着订单数据返回给页面。页面在更新数据的请求中，需要把这个版本号作为更新请求的参数，在带回给订单更新服务。

订单服务在更新数据的时候，需要比较订单当前数据的版本号，是否和消息中的版本号一直，如果不一致，就拒绝更新。如果版本号一致，还需要在更新版本号的同时，把版本号+1.“比较版本号、更新数据、版本号+1”，这个过程必须在同一个事务里面执行。

```
UPDATE orders set tracking_number = 666, version = version + 1
WHERE version = 8;
```

### 1.4 总结

上面实际就讲了一个事情：实现订单操作的幂等的方法。

因为网络、服务器等这些不确定的因素，重试请求是普遍存在并且不可避免的。具有幂等性的服务可以完美地克服重试导致的数据错误。

对于创建订单服务来说，可以通过预先生成订单号，然后利用数据库中订单号的唯一约束这个特性，避免冲入写入订单，实现创建订单服务的幂等性。

对于更新订单服务，可以通过一个版本号机制，每次更新数据前校验版本号，更新数据同时自增版本号，这样的方式来解决ABA问题，确保更新订单服务的幂等性。

通过这样两种幂等的方法，就可以保证，无论请求是不是重复，订单表中的数据，都是正确的。当然，实现订单幂等的方法，完全可以套用在其他需要实现幂等的服务中，只需要这个服务操作的数据保存在数据库中，并且又一张带有主键的数据表就可以了。

##  二、 商品详情页


##  三、 购物车系统


##  四、 账户余额系统


##  五、 多系统间的数据一致性


##  六、 商品搜索系统


##  七、 存储系统高可用


