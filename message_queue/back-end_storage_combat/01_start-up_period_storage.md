# Start-up period Storage


在一个电商系统的初创期，对于存储需要面对和解决的问题有：

```
创建和更新订单  —— 如何保证数据准确无误

商品详情页  ——  流量大、数据多，如何设计

购物车系统  —— 复杂而又重要，如何设计

账户余额系统 —— 余额总是对不上帐怎么办，事务

多个系统的的数据一致性 —— 如何保证，分布式事务

商品搜索系统 —— 如何构建，使用 Elaticsearch 

存储系统高可用 —— 如何将“删库跑路”的风险降到最低，备份与 MySQL MHA

```


## 一、订单系统

订单系统是整个电商系统中最重要的一个子系统，订单数据也是电商企业最重要的数据资产。在订单系统中的存储设计中，需要考虑的问题有那些？

一个合格的订单系统，最基本的要求是： **数据不能错**。

一个购物流程，有很多过程，需要更新很多表，在很多服务器和网络上可能出问题，所以订单系统的情况比较复杂。但要保证订单数据一笔都不能错，掌握了方法，并不难。

+ 首先，要保证代码没有bug；
+ 然后，要回正确的使用事务。通过事务，多个订单操作，要么全部成功，要么全部失败。

这些基本操作并不难，但每个订单系统在不同业务场景中，还可能有一些数据错误。但在讨论问题是，需要化繁为简，只考虑那些最核心的、通用的业务和功能，并以此来讨论存储技术问题。

### 1.1 订单系统的核心功能和数据

一个订单系统必备的功能，包含但远远不限于：

+ 1. 创建订单
+ 2. 随着购物流程更新订单状态
+ 3. 查询订单，包括用订单数据生成各种报表。

为了支撑这些必备功能，在数据库中，至少需要这样几个表：

+ 1. 订单主表：要叫订单表，保存订单的基本信息。
+ 2. 订单商品表：保存订单中的商品信息。
+ 3. 订单支付表：保存订单的支付和退款信息。
+ 4. 订单优惠表：保存订单的所有优惠信息。

这几个表之间的关系是： 订单主表和后面的几个子表都是一对多的关系，关联的外键就是订单主表的主键，也就是订单号。

绝大部分订单系统的核心功能和数据结构都是这样的。

### 1.2 如何避免重复下单

在“提交订单”是，如果手抖了一下，点了两下，或者网络问题，发了两个HTTP请求。这样就会创建两个完全一样的订单，所以订单要做防重。

前端页面可以做防重，但网络错误会导致重传，很多 RPC 框架、网络都会有自动重试机制，所以对于订单系统，重复请求的事情，是没有办法避免的。

解决办法是，**让你的订单具备幂等性**。幂等性，就是在操作中，任意多次执行所产生的影响与一次执行的影响相同。也就是说，一个幂等的方法，使用同样的参数，调用多次和调用一次，对系统产生的影响一样。
如果创建订单具有幂等性，就可以在数据库中只有一条新的创建的订单记录。

但还有一个问题是： 对于订单服务，它是如何知道一个请求是不是重复请求？

解决这个问题的最佳思路是： 数据库的每个表都要有主键，绝大部分数据表都遵循这个最佳实践。一般来说，我们在往数据库插入一条记录的时候，都不提供主键，由数据库在插入的同时，自动生成一个主键。这样就会重复的请求，就会导致插入重复数据。

我们知道，表的主键自带唯一属性，如果在一条 INSERT 语句中提供了主键，并且这个主键的值在表中已经存在，那么这条 INSERT 会执行失败，数据也不会写入表中。
**我们可以利用数据的这种“主键唯一约束”的特性，在插入数据时候带上主键，来解决订单服务的幂等性问题。**

具体的做法是，给订单系统增加一个“生成订单号”的服务，这个服务没有参数，返回值就是一个新的、全局唯一的订单号。在用户进入创建订单的页面时，前端先调用服务生成一个订单号，在提交订单时，请求带着这个订单号。

这个订单号，也就是订单表的主键，这样各种情况导致的重试，重复请求中都带着同一个订单号。订单服务在订单表中插入数据的时候，执行这些重复的 INSERT 语句的主键，也都是同一个订单号。数据库的唯一约束就可以保证，只有一次insert语句是执行成功的，这样就实现了创建订单服务幂等性。


### 1.3 如何解决ABA问题

上面解决重复下单，是创建订单时要具有幂等性。同样，订单系统的各种更新服务一样也要具有幂等性。

订单更新服务，比如支付、发货等步骤的更新操作，最后落到数据库订单库上，都是对订单主表的 update 操作。数据库的更新操作，本身就具有天然的幂等性，如把订单状态从“未支付”更新成“已支付”，执行一次和重复多次，都是已支付，天然具有幂等性。

但在订单更新时，还需要注意其他问题。在并发环境中，需要注意**ABA问题**。
比如一个订单，需要修改为 666，发起请求后，数据库更新为 666，这个数据库返回的响应丢失了；但觉得 666错误了，又发起一个更新 888的操作，这时数据库记录变为888；但前面修改666的操作，由于响应丢失，发起重试，又修改为 666了。
这时第二次和第三次的成功影响返回前端，但实际数据库中但记录为 666，并不是我们期望的 888.存在数据错误。

ABA 问题的解决，有一个通用的思路： 给订单主表增加一列，列名可以叫 version，也就是”版本号的意思。每次查询订单的时候，版本号要随着订单数据返回给页面。页面在更新数据的请求中，需要把这个版本号作为更新请求的参数，在带回给订单更新服务。

订单服务在更新数据的时候，需要比较订单当前数据的版本号，是否和消息中的版本号一直，如果不一致，就拒绝更新。如果版本号一致，还需要在更新版本号的同时，把版本号+1.“比较版本号、更新数据、版本号+1”，这个过程必须在同一个事务里面执行。

```
UPDATE orders set tracking_number = 666, version = version + 1
WHERE version = 8;
```

### 1.4 总结

上面实际就讲了一个事情：实现订单操作的幂等的方法。

因为网络、服务器等这些不确定的因素，重试请求是普遍存在并且不可避免的。具有幂等性的服务可以完美地克服重试导致的数据错误。

对于创建订单服务来说，可以通过预先生成订单号，然后利用数据库中订单号的唯一约束这个特性，避免冲入写入订单，实现创建订单服务的幂等性。

对于更新订单服务，可以通过一个版本号机制，每次更新数据前校验版本号，更新数据同时自增版本号，这样的方式来解决ABA问题，确保更新订单服务的幂等性。

通过这样两种幂等的方法，就可以保证，无论请求是不是重复，订单表中的数据，都是正确的。当然，实现订单幂等的方法，完全可以套用在其他需要实现幂等的服务中，只需要这个服务操作的数据保存在数据库中，并且又一张带有主键的数据表就可以了。

##  二、 商品系统——商品详情页

商品系统，相对订单系统，电商的商品系统主要功能就是增删改查商品信息，没有很复杂的业务逻辑，支撑的主要页面就是商品详情页。

这个商品系统的存储，仍然需要考虑两方面问题：

+ 第一，要考虑高并发问题。商品详情页，是DAU最高的页面之一，用户主要浏览商品信息。
+ 第二，要考虑的是商品数据规模的问题。商品详情页的数据规模，用六个字总结： **数量大，重量大**。

支持商品系统的存储，要保存这么多“大胖子”，还要支撑高并发，任务艰巨。

### 2.1 商品系统需要保存那些数据

通常一个商品详情页中的所有信息，总结一下，可以分为：

```
基本信息
    标题
    副标题
    价格
        原价
        促销价
    颜色（根据型号）
    ......
商品参数

商品介绍

图片视频

促销信息
推荐商品
评价
体验
配送信息
店铺信息

```

### 2.2 商品基本信息该如何存储？

### 2.3 使用 MongoDB 保存商品参数

### 2.4 使用 对象存储 保存图片和视频

### 2.5 将商品介绍静态化

### 2.6 总结

商品系统的存储，需要提供商品的基本信息、商品参数、图片和视频、商品介绍等等这些数据。
商品基本信息和商品参数分别保存在 MySQL 和 MonogoDB 中，用 Redis 作为前置缓存，图片和视频存放在对象存储中，商品介绍随着商品详情页一起静态化到商品静态页中。

商品系统的存储，可以总结成这样的图

```
                             客户
                          /   |   \
CDN服务器                     |
        商详静态页            |                    图片/视频
      iPhone11.html          |                    |
      （含商品介绍）           |                     |
           |                 |                    |
          溯源           价格等动态信息             溯源
           |                 |                     |
商品系统     |                |                   对象存储
        Nginx                |
           |               Tomcat
        iPhone11.html   |     |       |
        （含商品介绍）    |     |       |
                        |   Redis     |
                        |   缓存穿透   |
                        |            |
                    mysql          MongoDB

```

从这个图中看，这个一个商品系统的存储最终效果是什么样的？
图中实线（客户与商详静态页、价格等动态信息、图片/视频的访问，tomcat与Reids的访问）表示没访问一次商祥页，需要真正传输的数据，虚线表示当商祥页发生变化的时候才需要进行一次数据传输。
用户打开一个SKU的商详页时，首先去CDN获取商祥页的HTML，然后访问商品系统获取价格等频繁变化的信息，这些信息从Redis缓存中获取。图片和视频信息，从对象存储的CDN中获取。

分析一下效果，数据量最大的图片、视频和商品介绍都是从离用户最近的CDN服务商获取的，速度快，节约带宽。真正打到商品系统的请求，就是价格这些需要动态获取的商品信息，一般做一次Redis查询就可以了，基本不会有流量打到MySQL中。

这样一个商品系统的存储架构，把大部分请求都转移到了又便宜速度又快的 CDN服务器商，可以用很少量的服务器和带宽，扛住大量的并发请求。

##  三、 购物车系统

购物车系统，是电商系统中复杂而又重要的系统。

购物车系统，就是用户在选购商品时，下单之前，暂存用户想要购买的商品。

购物车系统的功能，主要就三个： 把商品加入购物车、购物车列表页、发起结算下单，再加上一个所有界面都要显示的购物车小图标。

购物车这几个功能对应的存储模型应该怎么设计？很简单，只要一个“购物车”实体就够了。主要属性打开一个购物车界面，看下就知道了。

购物车功能虽然简单，但设计存储时，还有一些特殊问题需要考虑：

### 3.1 设计购物车存储是需要把握什么原则？

### 3.2 如何设计“用户购物车”的存储？

### 3.3 总结

购物车系统的存储如何设计。

购物车系统的主要功能包括： 加购、购物车列表页、结算下单。核心的实体就只有一个“购物车”实体，它至少要包括： SKUID、数量、加购时间、勾选状态这几个属性。

在给购物车设计存储时，为了确保购物车内的数量在多端保持一直，以及用户登录前后购物车内商品能无缝衔接，除了每个用户的“用户购物车”之外，还要实现一个“暂存购物车”保存用户未登录时加购的商品，并在用户登录后自动合并“暂存购物车”和“用户购物车”。

暂存购物车存储在客户端浏览器或者 App 中，可以选择存放到 Cookie 或者 LocalStorage 中。用户购物车保存在服务端，可以选择使用 Redis 后者 MySQL 存储，使用 Redis 存储会有更高的性能，可以支撑更多的并发请求，使用 MySQL 是更常规通用的方式，便于应对变化，系统的扩展性更好。

##  四、 账户余额系统

账户系统，负责记录和管理用户账户的余额，这个余额就是每个用户临时存在电商的钱，来源可能是用户充值或退款退货等多种途径。

账户系统的用途也非常广泛，不仅是电商，各种互联网内容提供商、网络游戏服务商、电信运营商等，都需要账户系统来管理用户账户的余额，或者是虚拟货币。包括银行的核心系统，也同样包含一个账户系统。

从业务需求的角度分析，一个最小化的账户系统， 数据模型可以表示为：
|列名|数据类型|主键|非空|说明|
|--|--|--|--|--|
|user_id|bigint|是|是|用户ID|
|balance|bigint||是|账户余额|
|timestamp|date||是|更新时间|

这个表包括用户ID、账户余额和更新时间三个字段。每次交易的时候，根据用户ID去更新这个账户的余额就可以了。

### 4.1 为什么总是对不上仗？

### 4.2 使用数据库事务来保证数据一致性

### 4.3 理解事务的隔离级别

### 4.4 总结

账户系统，用于记录每个用户的余额，为了保证数据的可追溯性，还需要记录账户流水。流水记录只能新增，任何情况下都不允许修改和删除，每次交易的时候，需要把流水和余额放在同一个事务中一起更新。

事务具备原子性、一致性、隔离型、持久性四种基本特性，也就是ACID，它可以保证在一个事务中执行的数据更新，要么都成功，要么都失败。并且在事务执行过程中，中间状态的数据对其他事务是不可见的。

ACID是一种理想情况，特别是要完美地实现 CI，会导致数据库性能严重下降，所以 MySQL 提供的四种可选的隔离级别，牺牲一定的隔离性和一致性，用于换取高性能。这四种隔离级别中，只有 RC 和 RR 这两种隔离级别是常用的，它们唯一的区别是在进行事务中，其他事务对数据的更新是否可见。


##  五、 多系统间的数据一致性

账户系统需要用到数据库事务，事务可以很好解决交易类系统的数据一致性问题。

事务的原子性和持久性可以确保在一个事务内，更新多条数据，要么都成功，要么都失败。在一个系统内部可以使用数据库事务来保证数据一致性。那一笔交易，涉及到跨多个系统、多个数据库的时候，用单一的数据库事务就没办法解决来。

在之前的大系统时代，普遍的做法是，在设计时尽量避免这种跨系统跨数据库的交易。

但现在的技术趋势是云原生和微服务，大系统为被打散成多个小的微服务，每个微服务有自己的数据库，大数据库也被打散成多个小数据库。跨微服务和数据库的交易，就成为一种越来越普遍的情况。业务系统微服务化之后，不可避免地要面对跨系统的数据一致性问题。

如何来解决这种跨系统、跨数据库的数据一致性问题呢？分布式事务。


### 5.1 到底什么是分布式事务？

### 5.2 2PC：订单与优惠券的数据一致性问题

### 5.3 本地消息表： 订单与购物车的数据一致性问题

### 5.4 总结

如何用分布式事务的几种方法来解决分布式系统中的数据一致性问题。

对于订单和优惠券这种需要强一致性的分布式事务场景，可以采用 2PC 的方法来解决问题。

2PC 它的优点是强一致，但性能上和可用性上都有一些缺陷。本地消息表适用性更加广泛，虽然在数据一致性上有所牺牲，只能满足最终一致性，但有更好的性能，实现简单，系统的稳定性也很好，是一种非常实用的分布式事务的解决方案。

无论那种分布式事务的方法，其实都是把一个分布式事务，拆分成多个本地事务。**本地事务可以用数据库事务来解决，那分布式事务就专注于解决如何让这些本地事务保持一致的问题。**我们在遇到分布式一致性问题的实际，也有基于这个思想来考虑问题，再结合情况选择分布式事务的方法。

##  六、 商品搜索系统

如何用 Elasticsearch 构建商品搜索系统？

搜索这个特性可以说是无处不在，现在很少有网站或系统不提供搜索功能了，所以即使不是一个专业做搜索的程序员，也会遇到一些与搜索相关的需求。

搜索这个东西，表面看功能很简单，就是一个搜索框，输入关键字，然后搜索出来想要的内容就好了。搜索背后的实现，可以非常简单，简单到用SQL，like 一下就能实现；也可以很复杂，复杂到什么程度？非专业做搜索的互联网大厂，搜索团队也是前任规模，不仅有程序员，还有算法工程师、业务专家等。二者的区别也仅仅是，搜索速度的快慢，以及搜出来的内容好坏而已。

在电商系统中，用 Elasticsearch 来快速、低成本地构建一个田议案还不错的搜索系统。

### 6.1 理解倒序索引机制

### 总结

ES 本质上是一个支持全文搜索的分布式内存数据库，特别适合构建搜索系统。ES之所以有非常好的全文搜索性能，最重要的原因就是采用来倒排索引。

倒排索引，是一种特别为搜索而设计的索引结构，倒排索引先对需要索引的字段进行分词，然后以分词为索引组成一个查找树，这样就把一个全文匹配的查找转换成来对树的查找，这是倒排索引能够快速进行搜索的根本原因。

倒是，倒排索引相比于一般数据采用的B树索引，它的写入和更新性能都比较差，因此，倒排索引也只是适合全文搜索，不适合更新频繁的交易类数据。


##  七、 存储系统高可用

对于任何一个企业来说，数据安全的重要性都是不言而喻的。凡事涉及到数据的问题，都是损失惨重的大问题。

能够影响数据安全的事件，都是极小概率事件，比如说： 数据库宕机、磁盘损坏、甚至机房着火，还有“删库跑路”的梗，这些事一旦发生来，我们的业务就会损失惨重。

### 7.1 如何更安全地做数据备份和恢复？

### 7.2 配置 MySQL HA 实现高可用

### 7.3 总结

对于安全，需要了解两件事： 一是如何备份和恢复数据库中的数据，确保数据安全；二是如何来实现数据库的高可用，避免宕机停服。

虽然这是两个不同的问题，但解决这两个问题背后的实现原理是一样的。**高可用依赖的是数据复制，数据复制本质就是从一个库备份数据，然后恢复到另外一个库中去。**

数据备份时，使用低频度的全量备份配合 binlog 增量备份是一种常用且非常实用的方法，这种备份方法，可以把数据库的数据精确地恢复到历史上任意一个时刻，不仅仅能解决数据损坏的问题，也不用怕误操作、删库跑路这些事了。特别要注意的是，让备份数据尽量原理数据库。

对于mysql高可用，有几种典型的HA方案，在数据库可靠性、数据库可用性、性能和成本几个方面，各有利弊，你需要根据业务情况，做一个最优的选择，并且为可能存在的风险做好准备。

